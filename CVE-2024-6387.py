#!/usr/bin/env python3

'''
    CVE-2024-6387 checker
    Author: Mischa van Geelen <@rickgeex>
    
'''

import socket
import argparse
import ipaddress
import threading
from queue import Queue

class SSHChecker:
    vulnerable_versions = [
        'SSH-2.0-OpenSSH_8.5',
        'SSH-2.0-OpenSSH_8.6',
        'SSH-2.0-OpenSSH_8.7',
        'SSH-2.0-OpenSSH_8.8',
        'SSH-2.0-OpenSSH_8.9',
        'SSH-2.0-OpenSSH_9.0',
        'SSH-2.0-OpenSSH_9.1',
        'SSH-2.0-OpenSSH_9.2',
        'SSH-2.0-OpenSSH_9.3',
        'SSH-2.0-OpenSSH_9.4',
        'SSH-2.0-OpenSSH_9.5',
        'SSH-2.0-OpenSSH_9.6',
        'SSH-2.0-OpenSSH_9.7'
    ]

    excluded_versions = [
        'SSH-2.0-OpenSSH_8.9p1 Ubuntu-3ubuntu0.10',
        'SSH-2.0-OpenSSH_9.3p1 Ubuntu-3ubuntu3.6',
        'SSH-2.0-OpenSSH_9.6p1 Ubuntu-3ubuntu13.3',
        'SSH-2.0-OpenSSH_9.3p1 Ubuntu-1ubuntu3.6',
        'SSH-2.0-OpenSSH_9.2p1 Debian-2+deb12u3',
        'SSH-2.0-OpenSSH_8.4p1 Debian-5+deb11u3'
    ]

    def __init__(self, ip, port, timeout, result_queue):
        self.ip = ip
        self.port = port
        self.timeout = timeout
        self.result_queue = result_queue

    def get_ssh_sock(self):
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(self.timeout)
        try:
            sock.connect((self.ip, self.port))
            return sock
        except:
            return None

    def get_ssh_banner(self, sock):
        try:
            banner = sock.recv(1024)
            try:
                banner = banner.decode().strip()
            except UnicodeDecodeError:
                banner = banner.decode('latin1').strip()
            sock.close()
            return banner
        except Exception as e:
            return str(e)

    def check_vulnerability(self):
        sshsock = self.get_ssh_sock()
        if not sshsock:
            self.result_queue.put((self.ip, self.port, 'closed', "Port is closed"))
            return

        banner = self.get_ssh_banner(sshsock)
        if "SSH-2.0-OpenSSH" not in banner:
            self.result_queue.put((self.ip, self.port, 'failed', f"Unable to retrieve SSH banner: {banner}"))
            return

        if any(version in banner for version in SSHChecker.vulnerable_versions) and banner not in SSHChecker.excluded_versions:
            self.result_queue.put((self.ip, self.port, 'vulnerable', f"(running {banner})"))
        else:
            self.result_queue.put((self.ip, self.port, 'not_vulnerable', f"(running {banner})"))

class IPProcessor:
    @staticmethod
    def process_ip_list(ip_list_file):
        ips = []
        try:
            with open(ip_list_file, 'r') as file:
                ips.extend(file.readlines())
        except IOError:
            print(f" [-] Failed to read the file: {ip_list_file}")
        return [ip.strip() for ip in ips]

    @staticmethod
    def process_targets(targets):
        ips = []
        for target in targets:
            try:
                with open(target, 'r') as file:
                    ips.extend(file.readlines())
            except IOError:
                if '/' in target:
                    try:
                        network = ipaddress.ip_network(target, strict=False)
                        ips.extend([str(ip) for ip in network.hosts()])
                    except ValueError:
                        print(f" [-] Invalid CIDR format: {target}")
                else:
                    ips.append(target)
        return ips

def main():
    print(f"\nüö® CVE-2024-6387 RegreSSHion Checker by @rickgeex")
    print(f"-----------------------------------------------------")
    parser = argparse.ArgumentParser(description="Determine if servers are running a vulnerable version of OpenSSH.")
    parser.add_argument("targets", nargs='*', help="IP addresses, domain names, file paths containing IP addresses, or CIDR network ranges.")
    parser.add_argument("--port", type=int, default=22, help="Port number to check (default: 22).")
    parser.add_argument("-t", "--timeout", type=float, default=1.0, help="Connection timeout in seconds (default: 1 second).")
    parser.add_argument("-l", "--list", help="File containing a list of IP addresses to check.")

    args = parser.parse_args()
    targets = args.targets
    port = args.port
    timeout = args.timeout

    ips = []

    if args.list:
        ips.extend(IPProcessor.process_ip_list(args.list))

    ips.extend(IPProcessor.process_targets(targets))

    result_queue = Queue()
    threads = []

    for ip in ips:
        ip = ip.strip()
        checker = SSHChecker(ip, port, timeout, result_queue)
        thread = threading.Thread(target=checker.check_vulnerability)
        thread.start()
        threads.append(thread)

    for thread in threads:
        thread.join()

    total_scanned = len(ips)
    closed_ports = 0
    not_vulnerable = []
    vulnerable = []

    while not result_queue.empty():
        ip, port, status, message = result_queue.get()
        if status == 'closed':
            closed_ports += 1
        elif status == 'vulnerable':
            vulnerable.append((ip, message))
        elif status == 'not_vulnerable':
            not_vulnerable.append((ip, message))
        else:
            print(f"‚ö†Ô∏è [!] Server at {ip}:{port} has an issue: {message}")

    print(f"\n\nüõ°Ô∏è Number of non-vulnerable servers: {len(not_vulnerable)}\n")
    for ip, msg in not_vulnerable:
        print(f"   [+] Server at {ip} {msg}")
    print(f"\nüö® Number of potentially vulnerable servers: {len(vulnerable)}\n")
    for ip, msg in vulnerable:
        print(f"   [+] Server at {ip} {msg}")
    print(f"\nüîí Number of servers with port {port} closed: {closed_ports}")
    print(f"\nüìä Total number of targets scanned: {total_scanned}\n")

if __name__ == "__main__":
    main()
